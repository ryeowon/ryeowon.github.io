[ { "title": "iframe 삽입이 안 되는 이유", "url": "/posts/x-frame-options/", "categories": "Security, Web Security", "tags": "iframe, x-frame-options", "date": "2022-09-17 09:00:00 +0900", "snippet": "HTML &lt;iframe&gt; 태그는 HTML 문서에 다른 문서를 삽입할 때 사용한다.그러나 Google, Gmail, Naver 등의 페이지를 삽입하려고 하는 경우 아래처럼 연결을 허용하지 않는다.iframe 오류 원인https://www.google.com을 iframe으로 삽입하고자 할 때, 크롬 개발자 도구의 Console 창을 보면 Refused to display 'https://www.google.com/' in a frame because it set 'X-Frame-Options' to 'sameorigin'.라는 메시지를 확인할 수 있다.즉, 구글은 origin이 같은 페이지(도메인 이름, 포트 번호, 프로토콜이 같은 페이지)에서만 iframe으로 구글을 삽입할 수 있도록 하고 있다. 그 이유는 클릭재킹과 같은 공격들을 막기 위함이다. 따라서 localhost나 다른 개인 페이지에서 iframe을 이용해 www.google.com을 삽입할 수 없다. X-Frame-Options: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-OptionsX-Frame-Options 확인 방법X-Frame-Options는 HTTP Response Headers에 담겨 있다.개발자 도구에서 Network를 선택하여 페이지를 다시 로드하고, iframe으로 삽입하고자 했던 페이지를 선택하면 Response Headers를 볼 수 있다. 아래는 www.google.com을 삽입 시도했을 때의 response headers이고, x-frames-options가 SAMEORIGIN으로 설정되어 있는 것을 볼 수 있다.이 설정이 DENY로 되어 있는 경우에도 해당 페이지를 iframe으로 삽입할 수 없다.해결 방안iframe 대신 웹사이트에서 제공하는 API를 사용하자.구글의 경우 https://www.google.com 대신 https://www.google.com/webhp?igu=1 를 사용하면 삽입이 되긴 한다.이 페이지는 X-Frame-Options가 존재하지 않는다." }, { "title": "인터넷(Internet)이란?", "url": "/posts/what-is-the-internet/", "categories": "Network", "tags": "network, internet", "date": "2022-09-03 09:00:00 +0900", "snippet": "인터넷이란?인터넷은 전 세계적으로 연결되어있는 컴퓨터 네트워크 통신망을 말한다.인터넷의 시작인터넷의 원형은 ARPANET(아파넷)으로 알려져 있는데, 이는 Vint Cerf(빈트 서프)와 Bob Kahn(밥 칸)이 설계한 세계 최초의 패킷교환방식을 이용한 네트워크이다. 냉전 시대였던 당시에는 핵공격에도 살아남을 수 있는 통신 시스템이 필요했다. 컴퓨터 네트워크 개발의 선구자인 Paul Baran(폴 바란)은 정보를 블록(패킷)으로 쪼개어 분산된 네트워크를 통해 가능한 빨리 모든 방향으로 보내자는 아이디어를 냈다.그림에서 알 수 있듯이 중앙 집중식(Centralized) 네트워크를 이용하면 중앙 서버에 핵공격을 당했을 때 네트워크가 완전히 마비된다. 따라서 분산(Distributed) 네트워크를 이용하여 공격 받지 않은 부분을 통해서라도 통신할 수 있도록 하자는 것이다. 이 아이디어를 바탕으로 Distributed Packet-Switched Network인 ARPANET이 개발되었다. packet-switched network: 데이터가 패킷(데이터 조각) 단위로 나뉘어 전송되는 네트워크분산된 네트워크인터넷은 독립적으로 운영되는 네트워크로 구성되어 있다. 이는 패킷이 어떤 경로를 거쳐갈지, 누가 누구와 통신할지 결정하는 중앙 통제가 없는 완전히 분산된 시스템을 말한다. 이러한 시스템의 인터넷은 우리가 전 세계의 어떤 장치와도 소통할 수 있도록 만든다. referencehttps://www.youtube.com/watch?v=Dxcc6ycZ73Mhttps://netspecific.net/en/netspecific/network-curation" }, { "title": "딥러닝 모델 CS-Flow의 구조와 특징", "url": "/posts/cs_flow_architecture/", "categories": "AI, Deep Learning", "tags": "normalizing flows, cs-flow, anomaly detection", "date": "2022-08-26 09:00:00 +0900", "snippet": "Fully Convolutional Cross-Scale-Flows for Image-based Defect Detection를 읽고 작성하였습니다.요약CS-Flow는 fully convolutional Cross-Scale normalizing Flow를 뜻하며,정상 이미지만을 학습해 이상치를 탐지하는 Anomaly Detection 모델 중 하나이다.CS-Flow의 가장 큰 특징은 input 이미지 resize를 통해 3가지 크기의 이미지를 생성하고, 이를 동시에 연산하여 확률 분포를 생성한다는 것이다. 이 방법을 통해 fine-grained positional and contextual information, 즉 세밀한 위치 정보와 의미 정보를 유지할 수 있다고 한다.Architecture전체 구조전체적인 CS-Flow의 구조는 다음과 같다. input 이미지가 3가지 크기로 resize된다. 크기가 다른 3가지 이미지들[\\(x^{(1)}, x^{(2)}, x^{(3)}\\)]은 feature extraction 과정을 거쳐3차원 feature map [\\(y^{(1)}, y^{(2)}, y^{(3)}\\)]으로 변환된다.이때, extractor로는 논문에서 EfficientNet-B5를 사용하였으며, 이외의 다른 pretrained neural network를 사용할 수 있다. 이후 feature map들이 normalizing flows 과정을 거치면, 확률 분포 \\(p_{Z}\\)가 계산 된다. CS-Flow에서 사용되는 normalizing flows는 cross-scale flow로, 기존의 normalizing flows의 확장된 버전이다. 학습 과정에서는 최적의 확률 분포 \\(p_{Z}\\)를 찾고, 테스트 단계에서 확률 분포 \\(p_{Z}\\)를 이용해 likelyhood \\(p_{Z}(z)\\)를 도출하고 threshold 와 비교해 정상/비정상을 판단한다. (\\([z^{(1)}, z^{(2)}, z^{(3)}]=z\\))Normalizing Flows with Cross-Scale Flow다음은 CS-Flow의 Normalizing Flows의 block 구조이다. 점선으로 둘러쌓인 부분을 하나의 coupling block이라고 부르며, 논문에는 이 block을 4~5번 반복하는 것이 가장 좋다고 되어 있다.(실제로 테스트해본 결과, coupling block을 1개만 사용해도 성능이 매우 좋았고 모델 크기는 더 작았다.)먼저 channel이 절반으로 나뉘어 위쪽, 아래쪽으로 분리된다. 분리된 tensor들은 반대쪽 tensor에 영향을 주는 parameter들(scale, shift)을 구하는 cross-scale convolutions(\\(r_{1}\\)과 \\(r_{2}\\))에 사용된다. subnetwork \\(r_{1}\\)과 \\(r_{2}\\)는 각각 \\([s_{1}, t_{1}]\\)와 \\([s_{2}, t_{2}]\\)를 반환하는데, 이때 \\(s_{i}\\)는 scale parameter이고, \\(t_{i}\\)는 shift paramter이다.위의 식처럼 scale parameter \\(s_{i}\\)은 element-wise product 연산(\\(\\odot\\))에 사용되고, shift parameter \\(t_{i}\\)는 element-wise sum 연산(+)에 사용되며 \\(y_{out, i}\\)이 결정된다. 그 후 나뉘었던 channel이 다시 합쳐지며 \\(y_{out}\\)이 구해진다.Cross-Scale Convolutions위의 Normalizing flows에서 \\(r_{1}\\)과 \\(r_{2}\\)에 해당하는 부분을 자세히 나타낸 것이다.총 두 단계의 convolution이 이루어지는데, 첫 번째는 일반적인 2D convolution이고 두 번째가 cross convolution이다. cross convolution에서 크기가 다른 feature map들을 연산해 더하려면 크기를 똑같이 맞춰줘야 하기 때문에 stride를 조절하거나 upsampling을 한다. 아래쪽으로 내려가는 화살표는 stride를 2로 설정한 convolution을 통해 크기를 반으로 줄여주는 것이고, 올라가는 화살표는 upsampling을 통해 크기를 키워준 후 convolution하는 것이다. 두 단계의 convolution 후에 각 output이 element-wise로 더해지고, channel을 기준으로 절반으로 나뉘며, 각각 scale paramter와 shift paramter가 된다. referencehttps://github.com/marco-rudolph/cs-flowhttps://arxiv.org/pdf/2110.02855.pdf" }, { "title": "운영체제(Operating System)란?", "url": "/posts/operating_system/", "categories": "OS", "tags": "operating system", "date": "2022-08-08 09:00:00 +0900", "snippet": "Operating Systems: Three Easy Pieces를 읽고 정리한 글입니다.운영체제란?쉽게 말하면 운영체제(Operating System, OS)는 컴퓨터 프로그램이 잘 실행되도록 관리하는 소프트웨어이다.OS는 다음과 같은 역할을 한다. 프로그램을 쉽게 실행할 수 있게 하며, 우리 눈에 여러 프로그램이 동시에 실행되는 것처럼 보이게 한다. 여러 프로그램이 메모리를 공유하여 사용하도록 메모리를 관리한다. 프로그램이 마우스, 키보드와 같은 장치들과 상호작용하게 한다. 시스템이 정확하고 효율적이게 동작하고, 사용하게 쉽게 만든다.윈도우, 리눅스와 같은 것들이 운영체제의 예이다.Virtualization운영체제의 주요 역할은 가상화(Virtualization)이다.CPU, 메모리, 디스크와 같은 물리적 자원을 가상화하여 더 사용하기 쉽게 만드는데, 그래서 운영체제를 virtual machine이라고 부르기도 한다.Resource Manager많은 프로그램이 동시에 실행되면 프로그램들은 CPU와 메모리, 디스크 등을 공유하여 사용한다. CPU, 메모리, 디스크는 시스템의 자원들이며 이것을 관리하는 OS는 resource manager이라고도 불린다.운영체제는 이러한 자원들을 효율적으로 관리하고, 어떤 한 프로그램에 치중되지 않고 공평하게 사용될 수 있도록 한다.Standard LibraryOS는 사용자에게 할 일을 지시받는다. 사용자를 위해 OS는 많은 인터페이스를 제공하여 파일 접근, 프로그램 실행 등을 지시할 수 있도록 한다. 어플리케이션을 사용할 수 있도록 OS는 몇백 개의 system calls를 제공하고 있고, 따라서 OS는 어플리케이션에 standard library를 제공한다고 말하기도 한다.Design Goals 시스템을 편리하게 만들기 위하여 abstraction(추상화)하기 abstraction은 쉽게 말해 복잡한 것을 간추리는 것 성능을 높이고, overhead(extra instruction time, extra memory space 등)를 줄이는 것 어플리케이션 간의, 또는 어플리케이션과 OS간의 protection ( isolating processes ) 프로그램에서 발생한 오류가 다른 프로그램에 영향을 주지 않아야 함 신뢰성(reliability) OS는 멈추지 않아야 함. OS가 멈추면 모든 어플리케이션이 멈추게 됨 energy-efficiency, security, mobility 등 reference: https://pages.cs.wisc.edu/~remzi/OSTEP/intro.pdf" }, { "title": "pytorch optimizer란?", "url": "/posts/pytorch_optimizer/", "categories": "AI", "tags": "pytorch", "date": "2022-08-04 09:00:00 +0900", "snippet": "PyTorch Optimizer모델이 학습 단계에서 epoch를 거치면서 성능이 좋아지는 이유는 모델의 parameters를 조절해 loss 값을 줄이기 때문이다.모델의 parameters에는 가중치(weight)와 편향(bias) 등이 있다. 가중치와 편향에 관한 글: https://jh2021.tistory.com/3loss(손실)란 예측 값과 실제 값의 틀린 정도를 나타내는 수치로, 이것을 최소화하는 것이 학습 단계의 목적이다.이때 필요한 것이 optimizer이다. pytorch에서 제공하는 optimizer는 모델의 loss 값을 줄이는 방향으로 parameters를 조절한다.optimizer에는 다양한 종류가 있는데, 모델에 따라서 잘 맞는 optimizer가 존재한다.내가 사용해본 optimizer는 ADAM인데, 아래는 ADAM optimizer를 초기화하는 코드이다.optimizer = torch.optim.Adam(model.parameters(), lr=1e-4)학습하려는 모델의 parameters와 hyperparameter인 learning rate를 등록해주었다. 따로 넣어주지 않은 weight decay 등의 값은 기본 값으로 처리된다.최적화 과정각 학습 단계에서 최적화는 총 3단계로 이루어진다. optimizer.zero_grad() : parameter 변화도(gradient)를 0으로 초기화 loss.backwards() : prediction loss를 역전파(반대 방향으로 loss를 돌려보냄)하고, loss의 변화도를 저장 optimizer.step() : 저장한 변화도로 parameters를 조정 reference: https://pytorch.org/tutorials/beginner/basics/optimization_tutorial.html" }, { "title": "class variance 개념 정리", "url": "/posts/inter-class-vs-intra-class/", "categories": "AI", "tags": "class variance", "date": "2022-08-01 09:00:00 +0900", "snippet": "inter-class variace vs inter-class variance데이터 분석에서 데이터 분산을 표현할 때는 다음과 같은 용어를 사용한다. inter-class variance: class 간의 분산 intra-class variance: class 내부의 분산예를 들어 아래의 그림을 보자!!a) inter-class variance가 크고, intra-class variance가 작은 경우 빨간색, 파란색 두 클래스가 서로 떨어져 있음 -&gt; inter-class variance가 크다. 같은 색의 점들이 모여 있음 -&gt; intra-class variance가 작다.b) inter-class variance가 작고, intra-class variance가 큰 경우 빨간색, 파란색 두 클래스가 가까이 있음 -&gt; inter-class variance가 작다. 같은 색의 점들이 비교적 떨어져 있음 -&gt; intra-class variance가 크다. reference: https://www.statisticalaid.com/intra-class-vs-inter-class-correlation/" }, { "title": "Jekyll 블로그 폰트 바꾸기", "url": "/posts/customizing_font/", "categories": "Web, Jekyll", "tags": "web, jekyll", "date": "2022-07-18 09:00:00 +0900", "snippet": "지킬 테마를 이용해서 블로그를 만들고 나니 폰트가 너무 마음에 안 들었다 ..이 폰트 바꾸는 법 찾는 데만 며칠이 걸렸는데 …!! 하고 보니 아주 간단했다.이 방법은 내가 사용한 Chirpy 테마 기준이지만, 다른 지킬 테마에도 적용할 수 있을 거라 생각한다.폰트 고르기Google Fonts에 접속해 원하는 폰트를 클릭하면 다음과 같이 스타일을 선택하는 화면이 나온다.Select this style 버튼을 눌러 원하는 스타일을 모두 추가해준다.웹 페이지 오른쪽 상단의 View selected families 버튼을 누르면 다음과 같은 창이 뜨는데@import를 선택한 후 style 태그 안에 있는 부분을 복사해주고, 아래의 CSS rule을 확인해둔다.scss 파일 찾기블로그의 scss 파일에는 블로그 디자인과 관련된 코드들이 들어있다.그 중 글씨체 설정이 되어있는 부분을 찾아야 한다.먼저 블로그에 접속해 Ctrl+Shift+C를 누르고(Windows 기준), 바꾸고 싶은 글자를 클릭한다.그러면 해당 요소의 css를 확인할 수 있는데, 그 중 font-family 속성을 찾고 해당 코드가 있는 파일 이름과 라인 넘버를 확인한다.그 후 해당 파일을 찾아야 하는데, 보통 그 파일은 _sass 폴더 내에 있을 것이다.나의 경우 Chirpy Starter를 사용하여 _sass 폴더가 없어서 많이 헤맸는데, Chirpy Theme에서 그 폴더만 복사하여 사용하니 해결됐다.폰트 수정하기찾은 scss 파일 맨 위에에 복사한 코드를 넣어준다.//예시@import url('https://fonts.googleapis.com/css2?family=Gowun+Dodum&amp;display=swap');그 후, 위에서 찾은 라인 넘버를 따라가 font-family 요소를 찾고, 확인했던 CSS rule로 바꿔 준다.(위의 예시의 경우 commons.scss 파일의 32번째 줄)body { ... font-family: 'Gowun Dodum'; ...}끝!!" }, { "title": "ReactJS 80번 포트에 배포하기", "url": "/posts/ReactJS_deployment/", "categories": "Web, ReactJS", "tags": "web, react", "date": "2022-07-08 09:00:00 +0900", "snippet": "ReactJS를 npm run start로 실행하면 기본적으로 port 3000을 사용한다.이 포트를 바꾸고 싶을 때는 운영체제에 따라 다음과 같이 설정하고 npm run start로 실행하면 된다.//package.json (Linux)...\"scripts\": { \"start\": \"export PORT=1234 &amp;&amp; react-scripts start\", ...}...//package.json (Windows)...\"scripts\": { \"start\": \"set PORT=1234 &amp;&amp; react-scripts start\", ...}...그러나 포트 80번에서 실행하고 싶은 경우, 위와 같이 설정하면 다음과 같은 메시지가 뜨며 거부당한다… Admin permissions are required to run a server on a port below 10241024보다 작은 포트에서 실행하기 위해서는 admin permission이 있어야 한다는 것인데, 나의 경우 아무리 sudo를 이용해도 해결되지 않았다.(참고로 개발 환경은 Linux이다)해결 방법그래서 찾은 방법은 npm run build를 이용해 배포하는 것이다.$ npm run build$ sudo serve -l 80 -s build먼저, npm run build로 최적화된 파일들을 생성해주고, -l (포트번호)를 이용해 원하는 포트에 배포해준다." } ]
